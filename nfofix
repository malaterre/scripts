#!/usr/bin/env python3
""" fix movie for mini 4k / freebox + kodi  + minidlna """
import logging
import subprocess
import os
import sys
import argparse
import json
import zipfile
import xml.etree.ElementTree as ET


class FfmpegHelper(object):

    """ 
    """

    def __init__(self, input_file, output_dir = '/tmp/dbg'):
        self.input_file = input_file
        self.output_dir = output_dir
        self.ffprobe_command = 'ffprobe'
        self.ffprobe_data = None
        self.ffmpeg_command = 'ffmpeg'
        self.verbose = False

    def set_verbose(self, verbose):
        self.verbose = verbose

    def _raise_exception(self, message):
        if bool(self.unwrap_data):
            logging.error(json.dumps(self.unwrap_data, indent=4))
        if bool(self.ffprobe_data):
            logging.error(json.dumps(self.ffprobe_data, indent=4))
        logging.error(message)
        raise Exception(message)

    def _grab_info(self):
        """ Inspect info of AVI file for basic check
        """
        filename, file_extension = os.path.splitext(self.input_file)
        self.nfo_file = filename + '.nfo'
        command_line = [self.ffprobe_command, '-hide_banner', '-show_streams',
                        '-show_format', '-print_format', 'json', '-i', self.input_file]
        if not self.verbose:
            command_line.extend(['-v', 'error'])
        errcode, stdout, stderr = self.call_process(command_line, nolog=True)
        self.ffprobe_data = json.loads(stdout)
        print('coucou')
        if self.verbose:
            print('coucou')
            logging.info(json.dumps(self.ffprobe_data, indent=4))
        print('coucou')

    def _check_info(self):
        # Technical limitation:
        nb_streams = self.ffprobe_data['format']['nb_streams']
        if nb_streams != 1 and nb_streams != 2:
            self._raise_exception(
                "Invalid nb_streams value: %d" % nb_streams)

        # single stream, should be video:
        codec_type = self.ffprobe_data['streams'][0]['codec_type']
        codec_types = sorted([stream['codec_type']
                              for stream in self.ffprobe_data['streams']])
        if codec_types != ['video'] and ['audio', 'video'] != codec_types:
            self._raise_exception(
                "Codec Types are Unhandled: %s" % codec_types)

    def convert(self):
        self._grab_info()
        self._check_info()
        #filename, file_extension = os.path.splitext(self.input_file)
        #self.mp4_file = filename + '.mp4'
        #command_line = [self.ffmpeg_command,
        #                '-hide_banner', '-y', '-i', self.input_file]
        #if not self.verbose:
        #    command_line.extend(['-v', 'error'])
        ## remove any existing metadata from original video, and set PatientName as title
        ## and add StudyDate in comment field.
        #command_line.extend(['-map_metadata', '-1'])
        #title = self.unwrap_data['PatientName']
        #comment = "StudyDate: %s" % self.unwrap_data['StudyDate']
        #command_line.extend(['-metadata',  'title=%s' %
        #                     title, '-metadata', 'comment=%s' % comment])
        ## discard sound if any
        #command_line.extend(['-an'])
        ## MP4 container + AVC codec (legal requirement)
        #command_line.extend(self._compute_video_flag())
        ## move some information to the beginning of your file and allow the video
        ## to begin playing before it is completely downloaded by the viewer.
        #command_line.extend(['-movflags', '+faststart'])
        #command_line.extend([self.mp4_file])
        #errcode, stdout, stderr = self.call_process(command_line)

    def call_process(self, command_line_list, env=None, nolog=False):
        """ Thin wrapper over subprocess.call with logging functionality """
        logging.info(
            "Preparing to subprocess.call an external process with "
            "the following command line: %s ( %s )",
            command_line_list,
            " ".join(command_line_list))
        process = subprocess.Popen(command_line_list,
                                   stdin=subprocess.PIPE,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   shell=False,
                                   env=env)
        stdout, stderr = process.communicate()
        if sys.version_info[0] >= 3:  # Python 3
            stdout = stdout.decode("utf-8")
            stderr = stderr.decode("utf-8")
        binary = os.path.basename(command_line_list[0])
        errcode = process.returncode
        if errcode:
            self._raise_exception("Process %s exited with error code %d.\nThe process stdout is \n%s\nstderror is \n%s" % (
                binary, errcode, stdout, stderr))
        else:
            if not nolog and stderr != '':
                logging.info("The process stderr is \n%s", stderr)
        return errcode, stdout, stderr

def run(helper):
    helper.convert()


def main(args):
    #helper = FfmpegHelper(args.input, args.output)
    helper = FfmpegHelper(args.input)
    helper.set_verbose(args.verbose)
    run(helper)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="ffmpeg + nfo")
    parser.add_argument("input", help='input movie')
    #parser.add_argument("output", help='output folder')
    # verbose
    parser.add_argument("--verbose",
                        help="verbose output", action='store_true')
    main(parser.parse_args())
